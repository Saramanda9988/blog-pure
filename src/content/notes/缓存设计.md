---
publishDate: 2025-09-17
---

延迟双删 —— 延迟1~2秒进行删除，保证没有旧值

问题：两次删除缓存数据引起的缓存击穿以及短时间对数据库（主副本）造成的流量与负载压力

> 现实世界中的系统响应慢所带来的却是流量的加倍上涨。回想一下当你面对 App 响应慢的情况，是如何反应与对待便能明白，几乎所有用户的下意识行为都是如出一辙。

大部分系统的流量不高，使用缓存可以提高性能表现，当缓存失效时，数据库可以承受一部分负载压力
而对于流量巨大的系统而言，短时的访问流量穿透缓存访问数据库（主副本），恐怕很难接受。这时候相比于延迟双删在技术实现上带来高效便捷而言，其对系统的影响与副作用则变得不可忽视。

推特的解决方案 —— 租期Leases
是一种类似乐观锁的实现，代替延迟双删解决了

* 惊群效应（Thundering Herd）
* 陈旧写入（Stale Set）

![速率限制与令牌绑定](/photos/20250917222721.png)

> 进一步的，FB 还设置了 **Stale values** 机制，可以让业务来自行选择是否使用略微过期的数据来降低请求等待的时间。
> 当一个 key 被删除时，这个 key 的值被短暂的存储到一个过期数据的地方，但是这个时候memcache里面还没被写入新的值，这个时候如果业务不想等待，那么可以直接取走老的数据，从而加速响应时间。
